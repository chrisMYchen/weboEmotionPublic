var assert = require("assert"),
    epsilon = require("./utils/epsilon"),
    keyframes = require("../../lib/index"),
    JiboKeyframeInfo = require("../../lib/jibo-keyframe-info"),
    BodyLayerClass = require("../../lib/layers/body-layer"),
    propsDefault = {
        Head: 0.0,
        Torso: 0.0,
        Pelvis: 0.0
    },
    propsA = {
        Head: 1.0,
        Torso: 2.0,
        Pelvis: 3.0
    },
    propsB = {
        Head: 4.0,
        Torso: 5.0,
        Pelvis: 6.0
    },
    propsAB = {
        Head: (propsA.Head + propsB.Head)/2.0,
        Torso: (propsA.Torso + propsB.Torso)/2.0,
        Pelvis: (propsA.Pelvis + propsB.Pelvis)/2.0
    };

describe('keyframes.runtime', function(){
    describe('.evaluateLayer()', function(){
        it('should return defaults when there are no keyframes', function(){
            var newKeyframes = keyframes.runtime.create(JiboKeyframeInfo),
                props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, 0.0);

            keysShouldBeEqual(props, propsDefault);
        });

        it('should return the values of a keyframe if it\'s the only one, regardless of where in time it is', function(){
            var newKeyframes = keyframes.runtime.create(JiboKeyframeInfo);

            // Insert a keyframe into the middle of the animation's timeline
            newKeyframes.layers[0].keyframes.push({
                time: 15,
                value: propsA
            });

            // Test with a time before the keyframe and after
            var props;
                // Before
            props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, 0.2);
            keysShouldBeEqual(props, propsA);
                // After
            props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, 0.7);
            keysShouldBeEqual(props, propsA);
        });

        it('should hold the value of the last keyframe from any time after that keyframe\'s time and until the end of the animation', function(){
            var newKeyframes = keyframes.runtime.create(JiboKeyframeInfo);

            // Insert two keyframes, one at the beginning, and one in the middle
            newKeyframes.layers[0].keyframes.push({
                time: 0,
                value: propsA
            });
            newKeyframes.layers[0].keyframes.push({
                time: 15,
                value: propsB
            });

            var props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, 0.7);

            keysShouldBeEqual(props, propsB);
        });

        it('should interpolate between keyframe values when the time is between them', function(){
            // Test various pairs of keyframes interpolating
            validateInterpolation(0,1);
            validateInterpolation(15,16);
            validateInterpolation(28,29);
        });

        it('should use override values when it\'s provided', function(){
            var newKeyframes = keyframes.runtime.create(JiboKeyframeInfo),
                props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, 0.0, propsA);

            keysShouldBeEqual(props, propsA);
        });
    });
});

function keysShouldBeEqual(props, shouldBe){
    epsilon.equal(props.Head, shouldBe.Head, 0.0001, "Head rotation should be set to " + shouldBe.Head);
    epsilon.equal(props.Torso, shouldBe.Torso, 0.0001, "Torso rotation should be set to " + shouldBe.Torso);
    epsilon.equal(props.Pelvis, shouldBe.Pelvis, 0.0001, "Pelvis rotation should be set to " + shouldBe.Pelvis);
}

function validateInterpolation(startTime, endTime){
    var newKeyframes = keyframes.runtime.create(JiboKeyframeInfo);

    // Insert two keyframes, one at the beginning, and one in the middle
    newKeyframes.layers[0].keyframes.push({
        time: startTime,
        value: propsA
    });
    newKeyframes.layers[0].keyframes.push({
        time: endTime,
        value: propsB
    });

    var timeBetweenKeyframes = (startTime+endTime)/2.0 / JiboKeyframeInfo.defaults.framerate,
        props = keyframes.runtime.evaluateLayer(newKeyframes.layers[0], newKeyframes, JiboKeyframeInfo, timeBetweenKeyframes);

    keysShouldBeEqual(props, propsAB);
}

{
  "Subtree": {
    "description": "Executes a behavior tree (.bt) as a single behavior and returns the status of the subtree.",
    "type": "leaf",
    "options": [
      {
        "type": "Subtree",
        "field": "behaviorPath",
        "description": "Select a subtree.",
        "defaultValue": "null"
      },
      {
        "type": "Function",
        "field": "getNotepad",
        "description": "Enter optional information to return an object that will be this tree's notepad.",
        "defaultValue": "() => {\n    return {};\n}"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter optional code that will be called with the subtree's results with the subtree is done.",
        "defaultValue": "(treeResult) => {\n}"
      }
    ]
  },
  "SubtreeJs": {
    "description": "Dynamically executes a behavior tree (.bt) as a single behavior. This behavior returns the status of the subtree.",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "getFileName",
        "description": "Specify a subtree.",
        "defaultValue": "(callback) => {\n}"
      },
      {
        "type": "Function",
        "field": "getNotepad",
        "description": "Enter optional information to return an object that will be this tree's notepad.",
        "defaultValue": "() => {\n    return {};\n}"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter optional code that will be called with the subtree's results with the subtree is done.",
        "defaultValue": "(treeResult) => {\n}"
      }
    ]
  },
  "PlayAnimation": {
    "description": "Plays an animation file (.keys). Succeeds when the animation is finished.",
    "type": "leaf",
    "options": [
      {
        "type": "Animation",
        "field": "animPath",
        "description": "Select the animation file to play.",
        "defaultValue": "null"
      },
      {
        "type": "Function",
        "field": "config",
        "description": "Enter optional code to modify the animation's playback.",
        "defaultValue": "(animation) => {\n}"
      }
    ]
  },
  "PlayAudio": {
    "description": "Plays a single audio source. The audio format is any format supported by HTML5 audio. Succeeds when the audio file is finished playing",
    "type": "leaf",
    "options": [
      {
        "type": "Audio",
        "field": "audioPath",
        "description": "Enter the audio file path.",
        "defaultValue": "null"
      }
    ]
  },
  "LookAt": {
    "description": "Creates body and eye animations for looking at a point in 3D space",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "getTarget",
        "description": "Return the x, y, and z coordinates Jibo should look at.",
        "defaultValue": "() => {\n    return {x: 0, y: 0, z: 0};\n}"
      },
      {
        "type": "boolean",
        "field": "isContinuous",
        "description": "True for continuous mode look at. False for single-shot look at.",
        "defaultValue": false
      },
      {
        "type": "Function",
        "field": "config",
        "description": "Enter optional code to modify the lookAt behavior.",
        "defaultValue": "(lookAt) => {\n}"
      }
    ]
  },
  "Blink": {
    "description": "Animates Jibo's eye to blink once.",
    "type": "leaf",
    "options": []
  },
  "TextToSpeech": {
    "description": "Creates speech output for Jibo.",
    "type": "leaf",
    "options": [
      {
        "type": "SSML",
        "field": "words",
        "description": "Enter text for Jibo to say. Takes plain text or SSML markup.",
        "defaultValue": "Hello"
      },
      {
        "type": "Function",
        "field": "onWord",
        "description" : "Enter optional code to execute each time Jibo says a single word.",
        "defaultValue": "(word) => {\n}"
      }
    ]
  },
  "TextToSpeechJs": {
    "description": "Dynamically creates speech output for Jibo.",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "getWords",
        "description": "Return what you want Jibo to say.",
        "defaultValue": "(callback) => {\n    callback('Hello');\n}"
      },
      {
        "type": "Function",
        "field": "onWord",
        "description": "Enter optional code to execute each time Jibo says a single word.",
        "defaultValue": "(word) => {\n}"
      }
    ]
  },
  "StartOnAnimEvent": {
    "description": "Prevents the behavior it's decorating from starting until a specified event is received from an animation.",
    "type": "decorator",
    "options": [
      {
        "type": "string",
        "field": "eventName",
        "description": "Specify the event name (set on the animation's Event Layer) on which the animation should start."
      },
      {
        "type": "Function",
        "field": "onReceived",
        "description": "Enter optional code to execute after the event is received but before the behavior starts.",
        "defaultValue": "(animFileName, payload) => {\n}"
      }
    ]
  },
  "StartOnEvent": {
    "description": "Prevents behavior it's decorating from starting until specified event is received from the global emitter.",
    "type": "decorator",
    "options": [
      {
        "type": "string",
        "field": "eventName",
        "description": "Specify the event name you want to listen for the component to start."
      },
      {
        "type": "Function",
        "field": "onEvent",
        "description": "This function is called after the event was received but before the component starts.",
        "defaultValue": "() => {\n}"
      }
    ]
  },
  "SucceedOnEvent": {
    "description": "Forces the behavior it's decorating to succeed when an event is received from the global emitter.",
    "type": "decorator",
    "options": [
      {
        "type": "string",
        "field": "eventName",
        "description": "Specify the event name you want to listen for the component to start."
      },
      {
        "type": "Function",
        "field": "onEvent",
        "description": "This function is called after the event was received along with any payload.",
        "defaultValue": "() => {\n}"
      }
    ]
  },
  "SucceedOnEmbedded": {
    "description": "Succeeds a behavior upon hearing a built-in listening rule.",
    "type": "decorator",
    "options": [
      {
        "type": ["enum",
          {
            "label": "Hey Jibo",
            "display": "Hey Jibo",
            "value": "hey_jibo"
          }
        ],
        "field": "rule",
        "description": "Specify the name of the embedded rule you want to listen for (hey_jibo).",
        "defaultValue": "hey_jibo"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "(listener), event emitter for hey-jibo (asr, spkr) and error events.",
        "defaultValue": "(listener) => {\n\tlistener.on('hey-jibo', function(asrResult, speakerIds) {\n\n\t});\n}"
      }
    ]
  },
  "ListenEmbedded": {
    "description": "Listens only for an embedded rule (hey_jibo)",
    "type": "leaf",
    "options": [
      {
        "type": ["enum",
          {
            "label": "Hey Jibo",
            "display": "Hey Jibo",
            "value": "hey_jibo"
          }
        ],
        "field": "rule",
        "description": "Specify the name of the embedded rule you want to listen for (hey_jibo).",
        "defaultValue": "hey_jibo"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "(listener), event emitter for hey-jibo (asr, spkr) and error events.",
        "defaultValue": "(listener) => {\n\tlistener.on('hey-jibo', function(asrResult, speakerIds) {\n\n\t});\n}"
      }
    ]
  },
  "Listen": {
    "description": "Tells Jibo to listen for auditory input using Natural Language Understanding (NLU).",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "type": "Rule",
        "field": "rule",
        "description": "Specify the file path for the rule to use to parse Listen results.",
        "defaultValue": "null"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for hey-jibo (asr, spkr) and timeout() events.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', function(asrResult, speakerIds) {\n\n    });\n}"
      }
    ]
  },
  "SucceedOnListen": {
    "description": "Succeeds a behavior upon hearing a custom Natural Language Understand (NLU) rule.",
    "type": "decorator",
    "options": [
      {
        "type": "Function",
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "type": "Rule",
        "field": "rule",
        "description": "Specify the file path for the rule to use to parse Listen results.",
        "defaultValue": "null"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for hey-jibo (asr, spkr) and timeout() events.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', function(asrResult, speakerIds) {\n\n    });\n}"
      }
    ]
  },
  "ListenJs": {
    "description": "Tells Jibo to listen for auditory input using Natural Language Understanding (NLU).",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "type": "Function",
        "field": "getRule",
        "description": "Pass a custom listening rule into the callback.",
        "defaultValue": "(callback) => {\n    callback(\"TopRule = $* Hello World $*;\");\n}"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for cloud (asr, spkr), hey-jibo (asr, spkr), timeout (), incremental (asr, stop()), and end-of-speech() results.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', function(asrResult, speakerIds) {\n\n    });\n}"
      }
    ]
  },
  "SucceedOnListenJs": {
    "description": "Succeeds a behavior upon hearing a custom Natural Language Understand (NLU) rule.",
    "type": "decorator",
    "options": [
      {
        "type": "Function",
        "field": "getOptions",
        "description": "Set the dictionary of options that will be returned for the listening task.",
        "defaultValue": "() => {\n    let options = {\n        heyJibo: false,\n        detectEnd: false,\n        incremental: false,\n        authenticateSpeaker: ''\n    }\n    return options;\n}"
      },
      {
        "type": "Function",
        "field": "getRule",
        "description": "Pass a custom listening rule into the callback.",
        "defaultValue": "() => {\n    callback(\"TopRule = $* Hello World $*;\");\n}"
      },
      {
        "type": "Function",
        "field": "onResult",
        "description": "Enter code to execute when Jibo has heard input. (listener), event emitter for cloud (asr, spkr), hey-jibo (asr, spkr), timeout (), incremental (asr, stop()), and end-of-speech() results.",
        "defaultValue": "(listener) => {\n    listener.on('cloud', function(asrResult, speakerIds) {\n\n    });\n}"
      }
    ]
  },
  "TakePhoto": {
    "description": "Attempts to take a photo and return the image url in the onPhoto callback",
    "type": "leaf",
    "options": [
      {
        "type": ["enum",
          {
            "label": "Small (672x380) - coming soon!",
            "display": "Small (672x380)",
            "value": 1
          },
          {
            "label": "Medium (1280x720)",
            "display": "Medium (1280x720)",
            "value": 2
          },
          {
            "label": "Large (1920x1080) - coming soon!",
            "display": "Large (1920x1080)",
            "value": 3
          },
          {
            "label": "X-Large (2688x1520) - coming soon!",
            "display": "X-Large (2688x1520)",
            "value": 4
          }
        ],
        "field": "resolution",
        "description": "Specify the resolution of the photo you want to take.",
        "defaultValue": 2
      },
      {
        "type": "Function",
        "field": "onPhoto",
        "description" : "Set optional code to execute after the photo is taken. If successful, returns imageUrl; otherwise, returns error.",
        "defaultValue": "(error, imageUrl) => {\n}"
      },
      {
        "type": "boolean",
        "field": "noDistortion",
        "description": "True to remove camera distortion from the photo. False to keep camera distortion on the photo.",
        "defaultValue": true
      }
    ]
  },
  "ReadBarcode": {
    "description": "Attempts to read a barcode or QRcode and returns the barcode data",
    "type": "leaf",
    "options": [
      {
        "type": "Function",
        "field": "onBarcode",
        "description" : "Enter the code that will be called when the barcode is read. If successful, returns barcode/QRcode data; otherwise, returns error.",
        "defaultValue": "(error, data) => {\n}"
      }
    ]
  },
  "meta": {
    "version": 1
  }
}
